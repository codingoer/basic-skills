"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[5637],{96840:(e,a,n)=>{n.r(a),n.d(a,{data:()=>l});const l={key:"v-76021ac9",path:"/java/concurrency/lock/volatile.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"JMM",slug:"jmm",children:[]},{level:2,title:"volatile和synchronized的区别",slug:"volatile和synchronized的区别",children:[]}],filePathRelative:"java/concurrency/lock/volatile.md",git:{updatedTime:1639064924e3,contributors:[{name:"codingoer",email:"codingoer@163.com",commits:1}]}}},90615:(e,a,n)=>{n.r(a),n.d(a,{default:()=>o});const l=(0,n(66252).uE)('<p>由于volatile关键字是与Java的内存模型有关的。</p><p>volatile它所修饰的变量不保留拷贝，直接访问主内存中的</p><p>并发之原子性、可见性、有序性</p><p>原子性：原子性意味着一个时刻，只有一个线程能够执行一段代码</p><p>可见性，有序性的概念。</p><h2 id="jmm" tabindex="-1"><a class="header-anchor" href="#jmm" aria-hidden="true">#</a> JMM</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于可见性，Java提供了volatile关键字来保证可见性。</p><p>缓存一致性问题？？</p><h2 id="volatile和synchronized的区别" tabindex="-1"><a class="header-anchor" href="#volatile和synchronized的区别" aria-hidden="true">#</a> volatile和synchronized的区别</h2><ul><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li></ul>',11),i={},o=(0,n(83744).Z)(i,[["render",function(e,a){return l}]])},83744:(e,a)=>{a.Z=(e,a)=>{const n=e.__vccOpts||e;for(const[e,l]of a)n[e]=l;return n}}}]);