"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[8387],{55066:(e,r,a)=>{a.r(r),a.d(r,{data:()=>t});const t={key:"v-8845e9f4",path:"/data-structure/",title:"数据结构 - Data Structure",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"数据结构的构成",slug:"数据结构的构成",children:[]},{level:2,title:"按照逻辑结构类型分类",slug:"按照逻辑结构类型分类",children:[{level:3,title:"集合",slug:"集合",children:[]},{level:3,title:"线性结构",slug:"线性结构",children:[]},{level:3,title:"树",slug:"树",children:[]},{level:3,title:"图",slug:"图",children:[]}]},{level:2,title:"按照存储结构类型",slug:"按照存储结构类型",children:[{level:3,title:"顺序存储结构",slug:"顺序存储结构",children:[]},{level:3,title:"链式存储结构",slug:"链式存储结构",children:[]},{level:3,title:"索引存储结构",slug:"索引存储结构",children:[]},{level:3,title:"哈希(散列)存储结构",slug:"哈希-散列-存储结构",children:[]}]}],filePathRelative:"data-structure/README.md",git:{updatedTime:1639064924e3,contributors:[{name:"codingoer",email:"codingoer@163.com",commits:1}]}}},49893:(e,r,a)=>{a.r(r),a.d(r,{default:()=>p});var t=a(66252);const l=(0,t._)("h1",{id:"数据结构-data-structure",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#数据结构-data-structure","aria-hidden":"true"},"#"),(0,t.Uk)(" 数据结构 - Data Structure")],-1),n=(0,t.uE)('<h2 id="数据结构的构成" tabindex="-1"><a class="header-anchor" href="#数据结构的构成" aria-hidden="true">#</a> 数据结构的构成</h2><ul><li>逻辑结构 - 数据元素之间的逻辑关系</li><li>存储结构或物理结构 - 数据元素及其关系在计算机存储器中的存储方式</li><li>数据运算 - 数据元素的操作</li></ul><p><img src="https://image.hualihai.cn/blog/f959253ecb6748bc93fc5eb6bb060965" alt="组成"></p><h2 id="按照逻辑结构类型分类" tabindex="-1"><a class="header-anchor" href="#按照逻辑结构类型分类" aria-hidden="true">#</a> 按照逻辑结构类型分类</h2><h3 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h3><p><strong>元素之间的关系</strong> : 无</p><p><strong>特点</strong> : 数据元素属于同一集合，别无其他逻辑关系。</p><h3 id="线性结构" tabindex="-1"><a class="header-anchor" href="#线性结构" aria-hidden="true">#</a> 线性结构</h3><p><strong>元素之间的关系</strong> : 一对一</p><p><strong>特点</strong> : 开始元素和终端元素都是唯一的，其余元素都有且仅有一个前驱元素和一个后继元素</p><p><strong>按操作分类</strong> :</p>',11),i={href:"/data-structure/linear-list/",target:"_blank",rel:"noopener noreferrer"},h=(0,t.Uk)("线性表"),d={href:"/data-structure/queue/",target:"_blank",rel:"noopener noreferrer"},s=(0,t.Uk)("队列"),u={href:"/data-structure/stack/",target:"_blank",rel:"noopener noreferrer"},c=(0,t.Uk)("栈"),o=(0,t.uE)('<h3 id="树" tabindex="-1"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h3><p><strong>元素之间的关系</strong> : 一对多</p><p><strong>特点</strong> : 开始元素唯一，终端元素不唯一，除终端元素外，每个元素有一个或多个后继元素；除开始元素外，每个元素有且仅有一个前驱元素。</p><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图" aria-hidden="true">#</a> 图</h3><p><strong>元素之间的关系</strong> : 多对多</p><p><strong>特点</strong> : 所有元素都可能有多个前驱元素和多个后继元素。</p><h2 id="按照存储结构类型" tabindex="-1"><a class="header-anchor" href="#按照存储结构类型" aria-hidden="true">#</a> 按照存储结构类型</h2><h3 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构</h3><h3 id="链式存储结构" tabindex="-1"><a class="header-anchor" href="#链式存储结构" aria-hidden="true">#</a> 链式存储结构</h3><h3 id="索引存储结构" tabindex="-1"><a class="header-anchor" href="#索引存储结构" aria-hidden="true">#</a> 索引存储结构</h3><h3 id="哈希-散列-存储结构" tabindex="-1"><a class="header-anchor" href="#哈希-散列-存储结构" aria-hidden="true">#</a> 哈希(散列)存储结构</h3>',11),g={},p=(0,a(83744).Z)(g,[["render",function(e,r){const a=(0,t.up)("TOC"),g=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.iD)(t.HY,null,[l,(0,t.Wm)(a),n,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t._)("p",null,[(0,t._)("a",i,[h,(0,t.Wm)(g)])])]),(0,t._)("li",null,[(0,t._)("p",null,[(0,t._)("a",d,[s,(0,t.Wm)(g)])])]),(0,t._)("li",null,[(0,t._)("p",null,[(0,t._)("a",u,[c,(0,t.Wm)(g)])])])]),o],64)}]])},83744:(e,r)=>{r.Z=(e,r)=>{const a=e.__vccOpts||e;for(const[e,t]of r)a[e]=t;return a}}}]);