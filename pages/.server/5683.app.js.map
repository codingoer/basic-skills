{"version":3,"file":"5683.app.js","mappings":";;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ECtCA;;;;;;;ACA0E;AAC1E;;AAEA,CAAgH;AAChH,iCAAiC,+BAAe,uBAAuB,SAAS;;AAEhF,iDAAe;;;;;;;;ACNF;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D;AACA;AACA,SAAe;AACf;AACA;AACA;AACA;AACA;AACA","sources":["webpack://notebook/./.temp/pages/jvm/index.html.js","webpack://notebook/./.temp/pages/jvm/index.html.vue","webpack://notebook/./.temp/pages/jvm/index.html.vue?1d96","webpack://notebook/./node_modules/vue-loader/dist/exportHelper.js"],"sourcesContent":["export const data = {\n  \"key\": \"v-7448c627\",\n  \"path\": \"/jvm/\",\n  \"title\": \"GC 垃圾回收器\",\n  \"lang\": \"zh-CN\",\n  \"frontmatter\": {},\n  \"excerpt\": \"\",\n  \"headers\": [\n    {\n      \"level\": 2,\n      \"title\": \"Minor GC 或 Young GC\",\n      \"slug\": \"minor-gc-或-young-gc\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"Major GC 或\",\n      \"slug\": \"major-gc-或\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"Full GC\",\n      \"slug\": \"full-gc\",\n      \"children\": []\n    }\n  ],\n  \"filePathRelative\": \"jvm/README.md\",\n  \"git\": {\n    \"updatedTime\": 1639064924000,\n    \"contributors\": [\n      {\n        \"name\": \"codingoer\",\n        \"email\": \"codingoer@163.com\",\n        \"commits\": 1\n      }\n    ]\n  }\n}\n","<p>JVM模型</p>\n<p>分代，回收算法，垃圾回收器搭配和对比，类加载</p>\n<div class=\"custom-container danger\"><p class=\"custom-container-title\">错误</p>\n<p>Unrecognized VM option 'MetaspaceSize=128m'\nError: Could not create the Java Virtual Machine.\nError: A fatal exception has occurred. Program will exit.</p>\n</div>\n<p>类加加载器，不重启JVM，替换调已经加载的类。</p>\n<h1 id=\"gc-垃圾回收器\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#gc-垃圾回收器\" aria-hidden=\"true\">#</a> GC 垃圾回收器</h1>\n<p>map属于类维度的，不会被回收</p>\n<p>Full GC 的时间和次数是管理java的应用服务不得不考虑的问题</p>\n<p>Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。</p>\n<p>Major GC 是清理老年代。</p>\n<p>Full GC 是清理整个堆空间—包括年轻代和老年代。</p>\n<p>对象优先在Eden区分配:</p>\n<pre><code>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。大多数情况下，对象优先在Eden区中分配。当Eden区中没有足够空间进行分配时，将会触发一次Minor GC。\n</code></pre>\n<p>大对象直接进入老年代：\n所谓的大对象是指，需要大量连续内存空间的Java对象。例如：很长的字符串或者数组。虚拟机提供了一个-XX：PretenureSizeThreshold参数。令大于这个-XX：PretenureSizeThreshold设置值的对象，直接在老年代分配。</p>\n<p>长期存活的对象将进入老年代：\n虚拟机为了分代收集，对每一个对象定义了一个对象年龄计数器（Age）。如果对象在Eden出生，并且经过一次Minor GC后，仍然存活并且能被Survivor区中每熬过一次Minor GC，，年龄就会增加1岁。当年龄增加到默认的15岁时，就会晋升到老年代。</p>\n<pre><code>晋升为老年代的阙值通过参数-XX：MaxTenuringThreshold设置。\n</code></pre>\n<p>许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。</p>\n<p>这使得我们不用去关心到底是叫 Major GC 还是 Full GC，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。</p>\n<p>每次服务停止的时候，都会报这个警告</p>\n<p>Java HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.\nJava HotSpot(TM) 64-Bit Server VM warning: CMSFullGCsBeforeCompaction is deprecated and will likely be removed in a future release.</p>\n<p>当内存大小不足时，则会启动GC线程并停止应用线程</p>\n<p>Minor GC触发条件：当Eden区满时，触发Minor GC。</p>\n<p>Full GC触发条件：老年代空间不足; 通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>\n<h2 id=\"minor-gc-或-young-gc\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#minor-gc-或-young-gc\" aria-hidden=\"true\">#</a> Minor GC 或 Young GC</h2>\n<p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。每次 Minor GC 会<code>清理年轻代的内存</code>。</p>\n<ul>\n<li>\n<p>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC</p>\n</li>\n<li>\n<p>执行 Minor GC 操作时，不会影响到永久代。</p>\n</li>\n</ul>\n<h2 id=\"major-gc-或\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#major-gc-或\" aria-hidden=\"true\">#</a> Major GC 或</h2>\n<p>Major GC is cleaning the Tenured space。Major GC 是清理老年代。</p>\n<p>Minor GC触发Major GC</p>\n<h2 id=\"full-gc\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#full-gc\" aria-hidden=\"true\">#</a> Full GC</h2>\n<p>Full GC is cleaning the entire Heap – both Young and Tenured spaces.</p>\n<p>Full GC 是清理整个堆空间—包括年轻代和老年代。</p>\n<p>java.lang.OutOfMemoryError: PermGen space</p>\n<p>元空间与永久代的区别？？</p>\n","import { ssrRender } from \"./index.html.vue?vue&type=template&id=115c62f4\"\nconst script = {}\n\nimport exportComponent from \"/Users/lionel/VsCodeProjects/notebook/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['ssrRender',ssrRender]])\n\nexport default __exports__","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n"],"names":[],"sourceRoot":""}