{"version":3,"file":"3219.app.js","mappings":";;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;EC9DA;;;;;;;;ACA+E;AAC/E;;AAEA,CAAgH;AAChH,iCAAiC,+BAAe,uBAAuB,SAAS;;AAEhF,sDAAe;;;;;;;;ACNF;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D;AACA;AACA,SAAe;AACf;AACA;AACA;AACA;AACA;AACA","sources":["webpack://notebook/./.temp/pages/java/oop/class-base.html.js","webpack://notebook/./.temp/pages/java/oop/class-base.html.vue","webpack://notebook/./.temp/pages/java/oop/class-base.html.vue?03f9","webpack://notebook/./node_modules/vue-loader/dist/exportHelper.js"],"sourcesContent":["export const data = {\n  \"key\": \"v-8d1ea4c0\",\n  \"path\": \"/java/oop/class-base.html\",\n  \"title\": \"类的基础\",\n  \"lang\": \"zh-CN\",\n  \"frontmatter\": {},\n  \"excerpt\": \"\",\n  \"headers\": [\n    {\n      \"level\": 2,\n      \"title\": \"类的基本概念\",\n      \"slug\": \"类的基本概念\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"声明一个类实例\",\n      \"slug\": \"声明一个类实例\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"初始化代码块\",\n      \"slug\": \"初始化代码块\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"构造方法\",\n      \"slug\": \"构造方法\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"this关键字\",\n      \"slug\": \"this关键字\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"类和对象的声明周期\",\n      \"slug\": \"类和对象的声明周期\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"类的可见性范围\",\n      \"slug\": \"类的可见性范围\",\n      \"children\": []\n    }\n  ],\n  \"filePathRelative\": \"java/oop/class-base.md\",\n  \"git\": {\n    \"updatedTime\": 1639064924000,\n    \"contributors\": [\n      {\n        \"name\": \"codingoer\",\n        \"email\": \"codingoer@163.com\",\n        \"commits\": 1\n      }\n    ]\n  }\n}\n","<h1 id=\"类的基础\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#类的基础\" aria-hidden=\"true\">#</a> 类的基础</h1>\n<h2 id=\"类的基本概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#类的基本概念\" aria-hidden=\"true\">#</a> 类的基本概念</h2>\n<p><strong>定义了类本身，不会做什么事，不会分配内存。</strong></p>\n<ul>\n<li>类变量 (静态成员变量)</li>\n</ul>\n<p><strong>类型本身具有的属性</strong></p>\n<ul>\n<li>类方法 (静态成员方法)</li>\n</ul>\n<p><strong>类型本身可以进行的操作</strong></p>\n<p>类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。</p>\n<ul>\n<li>实例变量 (成员变量)</li>\n</ul>\n<p><strong>类型实例具有的属性，也称之为成员变量</strong></p>\n<ul>\n<li>实例方法 (成员方法)</li>\n</ul>\n<p><strong>类型实例可以进行的操作</strong></p>\n<p>实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。</p>\n<h2 id=\"声明一个类实例\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#声明一个类实例\" aria-hidden=\"true\">#</a> 声明一个类实例</h2>\n<p>与基本数据类型相比，<code>int a</code>这个语句，<code>int</code>就是类型，<code>a</code>就是实例。</p>\n<p><strong>定义了类本身，不会做什么事，不会分配内存。实例也称作对象</strong></p>\n<p>另外注意，实例变量不需要一开始就有值。</p>\n<div class=\"language-java ext-java line-numbers-mode\"><pre v-pre class=\"language-java\"><code><span class=\"token class-name\">Point</span> p<span class=\"token punctuation\">;</span>\np <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div></div><ol>\n<li><code>Point p</code>声明了一个变量，p是Point类型的</li>\n<li>声明变量本身<strong>只会分配存放位置的内存空间(栈内存)</strong>，这块空间还没有指向任何实际内容，只是存储实际内容的位置。</li>\n<li><code>p = new Point();</code>创建了一个实例或对象，然后赋值给了变量p。<strong>分配内存(堆内存)</strong> 之后给实例变量设置默认值</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>引用类型变量和数组一样，都有两块内存：一块存放实际内容，一块存放实际内容的位置。</li>\n<li>在创建对象的时候，所有的实例变量都会分配一个默认值。\n<ul>\n<li>数值类型变量的默认值是0</li>\n<li>boolean是false</li>\n<li>char是\\u0000</li>\n<li>引用类型是null</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"初始化代码块\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#初始化代码块\" aria-hidden=\"true\">#</a> 初始化代码块</h2>\n<p>初始化代码块的一般应用就是给变量赋值</p>\n<ul>\n<li>初始化代码块</li>\n</ul>\n<p><strong>在创建一个对象的时候，会先调用初始化代码块，然后才执行构造方法！！！</strong></p>\n<ul>\n<li>静态初始化代码块</li>\n</ul>\n<p><strong>在类加载的时候执行，在任何对象创建之前，且只执行一次！！！</strong></p>\n<h2 id=\"构造方法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#构造方法\" aria-hidden=\"true\">#</a> 构造方法</h2>\n<p>构造方法可以有多个，不同于一般方法，构造方法名称是固定的，与类名相同，并且没有返回值。</p>\n<p><strong>构造方法中如果有this调用，this调用必须放在第一行，如果调用别的构造方法，先调别的，然后再做调整。</strong></p>\n<div class=\"language-java ext-java line-numbers-mode\"><pre v-pre class=\"language-java\"><code><span class=\"token class-name\">Point</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\"><span class=\"line-number\">1</span><br></div></div><ol>\n<li>分配内存空间</li>\n<li>给实例变量设置默认值</li>\n<li>调用构造方法</li>\n</ol>\n<p><strong>默认构造方法</strong></p>\n<p>每个类都至少有一个构造方法，在<strong>通过new创建对象的过程</strong>中会被调用。构造方法没有什么其他操作可以省略，Java编译器会自动生成一个默认的构造方法。</p>\n<p><strong>记住，一旦定义了构造方法，Java就不会再自动生成默认的构造方法了！！！</strong></p>\n<p><strong>私有构造方法</strong></p>\n<ol>\n<li>不能创建类的实例，如<code>Math</code>类，只能被静态访问</li>\n<li>能创建类的实例，但只能被类的静态方法调用。即类的对象有但是只能有一个</li>\n<li>只是被其他多个构造方法调用</li>\n</ol>\n<h2 id=\"this关键字\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#this关键字\" aria-hidden=\"true\">#</a> this关键字</h2>\n<p><strong>在实例方法中有一个隐含的参数，这个参数就是当前操作的实例自己，this表示当前实例</strong></p>\n<ul>\n<li>this引用一个对象，是实实在在存在的</li>\n<li>可以作为函数参数，<strong>可以作为返回值</strong></li>\n</ul>\n<p><strong>在构造方法中调用其他构造方法，this必须放在第一行！！！</strong></p>\n<h2 id=\"类和对象的声明周期\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#类和对象的声明周期\" aria-hidden=\"true\">#</a> 类和对象的声明周期</h2>\n<ol>\n<li>类加载</li>\n</ol>\n<p>当第一次通过new创建一个类的对象时，或者通过类名访问类变量和类方法时，Java会将类加载进内存，为这个类分配一块空间，这个空间包括类的定义，变量和方法信息。（<strong>类加载进内存，会放到方法区</strong> ）</p>\n<p>同时<strong>还有类的静态变量</strong>，接下来会对静态变量赋初始值。</p>\n<p>类加载进内存后，一般不会释放，直到程序结束。<strong>一般情况下，类只会加载一次。所以静态变量在内存中只有一份。</strong></p>\n<ol start=\"2\">\n<li>创建对象</li>\n</ol>\n<p>通过new创建一个对象的时候，对象产生，在内存中会存储这个对象的实例变量的值。<strong>每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。</strong></p>\n<p>注意，每个实例对象除了保存实例变量的值外，<strong>还保存着对应类型的地址，也即是类的地址</strong>。这样通过对象就是能知道类。</p>\n<ol start=\"3\">\n<li>内存</li>\n</ol>\n<p>对象和数组一样，有两块内存。<strong>保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。</strong></p>\n<ul>\n<li>栈中的内容是自动管理的</li>\n<li>堆中的内存是被垃圾回收机制管理的</li>\n</ul>\n<h2 id=\"类的可见性范围\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#类的可见性范围\" aria-hidden=\"true\">#</a> 类的可见性范围</h2>\n<p>Java中使用包的概念来解决命名冲突。带完整包名的类名称为<strong>完全限定名</strong></p>\n<p>同一个包下面的类之间引用式不需要包名的，可以直接引用。</p>\n<p><strong>如果什么可见性修饰符都不写，它的可见性范围就是同一个包内(不包括子包)，同一个包内的其他类可以访问。</strong></p>\n<p>可见性范围大小：</p>\n<p><strong>private &lt; 默认包 &lt; protected &lt; public</strong></p>\n","import { ssrRender } from \"./class-base.html.vue?vue&type=template&id=835fc0a0\"\nconst script = {}\n\nimport exportComponent from \"/Users/lionel/VsCodeProjects/notebook/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['ssrRender',ssrRender]])\n\nexport default __exports__","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n"],"names":[],"sourceRoot":""}